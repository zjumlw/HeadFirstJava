## 构造器与垃圾收集器
### 内存空间
内存中的两种区域：对象的生存空间堆（heap）和方法调用及变量的生存空间栈（stack）。

> 实例变量是被声明在类而不是方法里面，代表每个独立对象的字段，存在与所属的对象中。

> 局部变量和方法的参数被声明在方法里，是暂时的，生命周期只限于方法被放在栈上的这段时间，

要点：
- 实例变量是声明在类中方法之外的地方。
- 局部变量声明在方法或者方法的参数上。
- 所有局部变量都存在于栈上相对应的堆栈块中。
- 对象引用变量与primitive主数据类型变量都是放在栈上。
- 不管是实例变量或局部变量，对象本身都在堆上。

### 构造函数
编译器只会在你完全没有设定构造函数时才会调用。如果已经写了一个有参数的构造函数，且需要一个没有参数的构造函数，则必须手动编写它。  
如果类有一个以上的构造函数，则参数一定要不一样（包括参数的顺序和类型）。  
```java
public class Mushroom{
	public Mushroom(int size){}
	public Mushroom(){}
	public Mushroom(boolean isMagic){}
	public Mushroom(boolean isMagic, int size){}
	public Mushroom(int size, boolean isMagic){}
}
```

要点：
- 实例变量保存在所属的对象中，位于堆上。
- 如果实例变量是个对象的引用，则引用和对象都是在堆上；如果只是声明了对象，但并没有实际构造该对象，则不需要分配对象的空间。
- 构造函数是个会在新建对象的时候执行程序代码。
- 用构造函数初始被创建对象的状态。
- 如果没有编写构造函数，编译器会安排一个。
- 默认构造函数是没有参数的。
- 如果写了构造函数，编译器就不会调用。
- 最好有无参数的构造函数，可以使用默认值。
- 重载的构造函数意思是超过一个以上的构造函数。
- 重载的构造函数必须有不同的参数。
- 两个构造函数的参数必须不同（包括类型或顺序）。
- 实例变量有默认值，原始默认值是0/0.0/false，引用的默认值是null。

从某个构造函数调用重载版的另一个构造函数：
- 使用this()来调用；
- this()只能用在构造函数中，且必须是第一行语句；
- super()与this()不能兼得。



创建新对象时，所有**继承**下来的构造函数都会执行。

**抽象类**的构造函数会在具体子类创建出实例的时候执行。

构造函数执行的时候，**第一件事**是执行它的父类构造函数。







### 对象的声明周期
局部变量只会村会在声明该变量的方法中；  
实例变量的寿命与对象相同。  

三种方法可以释放对象的引用：
1. 引用永久性的离开它的范围；
2. 引用被赋值到其他的对象上；
3. 直接将引用设定为null。

